name: Auto Semantic Release

on:
  push:
    branches: [ main ]

permissions:
  contents: write
  actions: read
  # releases: write (implícito via contents para create-release action)

concurrency:
  group: auto-release-main
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Configure Git identity
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          echo "Git identity configurada:" >> "$GITHUB_STEP_SUMMARY"
          git config --list | grep -E 'user.name|user.email' >> "$GITHUB_STEP_SUMMARY"

      - name: Wait for CI success (required)
        id: waitci
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          OWNER_REPO="$GITHUB_REPOSITORY"
          SHA="$GITHUB_SHA"
          CURRENT_RUN_ID="$GITHUB_RUN_ID"
          TARGET_WORKFLOW_NAMES="CI" # pode adicionar mais separados por vírgula
          IFS=',' read -r -a WF_ARRAY <<< "$TARGET_WORKFLOW_NAMES"
          echo "Aguardando sucesso dos workflows: $TARGET_WORKFLOW_NAMES para SHA $SHA" >> "$GITHUB_STEP_SUMMARY"
          MAX_ATTEMPTS=40
          SLEEP=15
          ci_ok=false
          require_count=${#WF_ARRAY[@]}
          attempt=1
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            RESP=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H 'Accept: application/vnd.github+json' \
              "https://api.github.com/repos/$OWNER_REPO/actions/runs?head_sha=$SHA&event=push&per_page=100")
            # Para cada workflow requerido verificar se há um run completed success mais recente que não seja este
            success_count=0
            failed=false
            for wf in "${WF_ARRAY[@]}"; do
              # Seleciona o último run desse workflow
              WF_JSON=$(echo "$RESP" | jq --arg NAME "$wf" '.workflow_runs | map(select(.name==$NAME)) | sort_by(.run_number) | last')
              if [ "$WF_JSON" = "null" ]; then
                continue
              fi
              WF_ID=$(echo "$WF_JSON" | jq -r '.id')
              STATUS=$(echo "$WF_JSON" | jq -r '.status')
              CONCLUSION=$(echo "$WF_JSON" | jq -r '.conclusion')
              if [ "$WF_ID" = "$CURRENT_RUN_ID" ]; then
                # ignora o próprio run caso nomes coincidam
                continue
              fi
              if [ "$STATUS" = "completed" ]; then
                if [ "$CONCLUSION" = "success" ]; then
                  success_count=$((success_count+1))
                else
                  failed=true
                  echo "Workflow '$wf' terminou com conclusão '$CONCLUSION'" >> "$GITHUB_STEP_SUMMARY"
                fi
              fi
            done
            if $failed; then
              echo "CI falhou. Nenhuma release será criada." >> "$GITHUB_STEP_SUMMARY"
              ci_ok=false
              break
            fi
            if [ $success_count -ge $require_count ]; then
              ci_ok=true
              echo "Todos os workflows requeridos concluídos com sucesso." >> "$GITHUB_STEP_SUMMARY"
              break
            fi
            echo "Tentativa $attempt/$MAX_ATTEMPTS: aguardando ($success_count/$require_count prontos)..." >&2
            sleep "$SLEEP"
            attempt=$((attempt+1))
          done
          if [ "$ci_ok" = true ]; then
            echo "ci-ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ci-ok=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip release (CI not successful)
        if: steps.waitci.outputs.ci-ok != 'true'
        run: |
          {
            echo "Pulando geração de release pois CI não passou ou não foi encontrado.";
            echo "Nenhuma alteração adicional executada.";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Determine next version
        if: steps.waitci.outputs.ci-ok == 'true'
        id: version
        shell: bash
        run: |
          set -euo pipefail
          git fetch --tags --force
          # Última tag sem considerar 'latest'
          LAST_TAG=$(git tag -l 'v[0-9]*' --sort=-v:refname | head -n1 || true)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="v1.0.0"
            BASE_VERSION="1.0.0"
            echo "Nenhuma tag encontrada, iniciando em $LAST_TAG" >&2
          else
            BASE_VERSION=${LAST_TAG#v}
          fi

          # Commits desde a última tag
          if git rev-parse "$LAST_TAG" >/dev/null 2>&1; then
            RANGE="$LAST_TAG..HEAD"
          else
            RANGE="HEAD"
          fi
          COMMITS=$(git log --format=%s "$RANGE" || true)
          if [ -z "$COMMITS" ]; then
            echo "Nenhum commit novo desde $LAST_TAG. Abortando release." >&2
            echo "release-needed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          printf 'Commits considerados:\n%s\n' "$COMMITS" >&2

          BUMP="patch"
          if echo "$COMMITS" | grep -E '(BREAKING CHANGE|!:)' -q; then
            BUMP="major"
          elif echo "$COMMITS" | grep -E '^feat(\(|:)' -q; then
            BUMP="minor"
          elif echo "$COMMITS" | grep -E '^(fix|perf|refactor|chore|bug|hot|hotfix)(\(|:)' -q; then
            BUMP="patch"
          else
            # Apenas docs / ci / style / test? Pode optar por não lançar.
            if ! echo "$COMMITS" | grep -E '^(docs|ci|style|test|build)(\(|:)' -q; then
              BUMP="patch"
            else
              echo "Somente mudanças não-release (docs/ci/style/test/build). Abortando." >&2
              echo "release-needed=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          MAJOR=${BASE_VERSION%%.*}
          REST=${BASE_VERSION#*.}
          MINOR=${REST%%.*}
            PATCH=${BASE_VERSION##*.}

          case $BUMP in
            major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR+1)); PATCH=0 ;;
            patch) PATCH=$((PATCH+1)) ;;
          esac

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "Bump: $BUMP -> $NEW_VERSION" >&2
          {
            echo "new-version=$NEW_VERSION";
            echo "last-tag=$LAST_TAG";
            echo "release-needed=true";
          } >> "$GITHUB_OUTPUT"

          # Monta notas simples (pode ser refinado futuramente)
          NOTES_FILE=release_notes.md
          {
            echo "# Release $NEW_VERSION";
            echo;
            echo "Base: $LAST_TAG";
            echo;
            echo "## Commits";
            git log --pretty='- %s (%h)' "$RANGE";
          } > "$NOTES_FILE"
          echo "notes-file=$NOTES_FILE" >> "$GITHUB_OUTPUT"

      - name: Create annotated tag & move latest
        if: steps.waitci.outputs.ci-ok == 'true' && steps.version.outputs.release-needed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          NEW_VERSION='${{ steps.version.outputs.new-version }}'
          # Cria tag se não existir (idempotência guard)
          if git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
            echo "Tag $NEW_VERSION já existe. Pulando criação." >&2
          else
            git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          fi
          # Atualiza/move latest
          if git rev-parse latest >/dev/null 2>&1; then
            git tag -d latest
            git push origin :refs/tags/latest || true
          fi
          git tag -a latest -m "Alias para $NEW_VERSION"
          git push origin "$NEW_VERSION"
          git push origin latest

      - name: Create GitHub Release
        if: steps.waitci.outputs.ci-ok == 'true' && steps.version.outputs.release-needed == 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.new-version }}
          release_name: ${{ steps.version.outputs.new-version }}
          body_path: ${{ steps.version.outputs.notes-file }}
          draft: false
          prerelease: false

      - name: Summary
        if: steps.waitci.outputs.ci-ok == 'true' && steps.version.outputs.release-needed == 'true'
        run: |
          {
            echo "Release criado: ${{ steps.version.outputs.new-version }}";
            echo "Última tag anterior: ${{ steps.version.outputs.last-tag }}";
            echo "'latest' agora aponta para ${{ steps.version.outputs.new-version }}";
          } >> "$GITHUB_STEP_SUMMARY"
